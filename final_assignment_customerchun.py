# -*- coding: utf-8 -*-
"""Final_Assignment_customerchun.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h2o-sN0w5H31tzv1vtnKBlEvTa2WvHMn
"""

!pip install -U ipykernel

!pip install streamlit

!pip install pyngrok

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import warnings
from sklearn.preprocessing import LabelEncoder
from sklearn.decomposition import PCA
from sklearn.feature_selection import RFE
from sklearn.feature_selection import RFECV
from sklearn.feature_selection import SelectKBest, chi2
from sklearn.metrics import accuracy_score, f1_score
from sklearn.metrics import f1_score,confusion_matrix
from sklearn.model_selection import train_test_split
import xgboost as xgb
from sklearn.metrics import auc

# Commented out IPython magic to ensure Python compatibility.
np.set_printoptions(precision=3)
pd.set_option('display.float_format', lambda x: '%.3f' % x)
warnings.filterwarnings('ignore')
np.random.seed(8)
# %matplotlib inline

data=pd.read_csv('https://raw.githubusercontent.com/Diane10/ML/master/Customer-Churn.csv')
print(data.head())

data.Churn.value_counts()

categorical_feature_columns = list(set(data.columns) - set(data._get_numeric_data().columns))
categorical_feature_columns

newdata= data.drop(['TotalCharges'],axis=1)

le=LabelEncoder()

for column in newdata.columns:
    if newdata[column].dtype==np.number:
      continue
    newdata[column]=LabelEncoder().fit_transform(newdata[column])
newdata

newdata.info()

numerical_feature_columns = list(newdata._get_numeric_data().columns)
numerical_feature_columns

def generate_accuracy_and_heatmap(model, x, y):
#     cm = confusion_matrix(y,model.predict(x))
#     sns.heatmap(cm,annot=True,fmt="d")
    ac = accuracy_score(y,model.predict(x))
    f_score = f1_score(y,model.predict(x))
    
    print('Accuracy is: ', ac)
    print('F1 score is: ', f_score)
    
    print ("\n")
    print (pd.crosstab(pd.Series(model.predict(x), name='Predicted'),
                       pd.Series(y['Churn'],name='Actual')))
    return 1

newdata.info()

target = 'Churn'

k = 19 #number of variables for heatmap
cols = newdata[numerical_feature_columns].corr().nlargest(k, target)[target].index
cm = newdata[cols].corr()
plt.figure(figsize=(30,16))
sns.heatmap(cm, annot=True, cmap = 'viridis')

selectedcol=['tenure','Contract','OnlineSecurity','TechSupport','OnlineBackup','DeviceProtection','MonthlyCharges']

"""question2:"""

features = newdata[selectedcol]
columns = features.columns
# new_data.groupby(i)['Churn'].count()
for i in columns:
    print(newdata.groupby(i)['Churn'].count())

X = newdata.loc[:, newdata.columns != target]
Y = newdata.loc[:, newdata.columns == target]

X.shape

Y.shape

x_train, x_test, y_train, y_test = train_test_split(X, Y, 
                                                    test_size=0.33, 
                                                    random_state=8)

model= xgb.XGBClassifier(n_estimators=100,seed=30)
model.fit(x_train,y_train)

generate_accuracy_and_heatmap(model, x_test, y_test)

select_feature = SelectKBest(chi2, k=5).fit(x_train, y_train)

selected_features_df = pd.DataFrame({'Feature':list(x_train.columns),
                                     'Scores':select_feature.scores_})
selected_features_df.sort_values(by='Scores', ascending=False)

#Creation of model

import xgboost as xgb
import pickle

X = newdata[['tenure','Contract','OnlineSecurity','TechSupport','OnlineBackup','DeviceProtection','MonthlyCharges']]
y = newdata['Churn']
#y = y.astype('int')
#X = X.astype('int')
# print(X,y)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)
xgbmodel = xgb.XGBClassifier(n_estimators=100,seed=30)
import pickle

xgbmodel.fit(X_train.values,y_train.values)

pickle.dump(xgbmodel,open('models.pkl','wb'))

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
#  
# import streamlit as st 
# import numpy as np 
# import pandas as pd
# import matplotlib.pyplot as plt
# from sklearn import datasets
# from sklearn.model_selection import train_test_split
# from sklearn.decomposition import PCA
# from sklearn.svm import SVC
# from sklearn.neighbors import KNeighborsClassifier
# from sklearn.ensemble import RandomForestClassifier
# from sklearn.metrics import accuracy_score,plot_confusion_matrix,plot_roc_curve,precision_score,recall_score,precision_recall_curve,roc_auc_score,auc
# from sklearn.preprocessing import LabelEncoder
# from sklearn.linear_model import LogisticRegression
# import matplotlib.pyplot as plt
# import pickle
# import seaborn as sns
# import numpy as np
# xgbmodel=pickle.load(open('models.pkl','rb'))
#  
#  
#  
# import xgboost as xgb
#  
# import warnings
# warnings.filterwarnings('ignore')
#  
#  
# data=pd.read_csv('https://raw.githubusercontent.com/Diane10/ML/master/Customer-Churn.csv')
#  
# #fetuare extracting
# #q1 Using the given dataset extract the relevant features that can define a customer churn. [5]
# cols=['tenure','Contract','OnlineSecurity','TechSupport','OnlineBackup','DeviceProtection','MonthlyCharges','Churn']
# newdata=data[cols]
# target = 'Churn'
# le=LabelEncoder()
# le=LabelEncoder()
#  
#  
# newdata['Contract']=le.fit_transform(newdata['Contract'])
# newdata['OnlineSecurity']=le.fit_transform(newdata['OnlineSecurity'])
# newdata['TechSupport']=le.fit_transform(newdata['TechSupport'])
# newdata['OnlineBackup']=le.fit_transform(newdata['OnlineBackup'])
# newdata['DeviceProtection']=le.fit_transform(newdata['DeviceProtection'])
# newdata['Churn']=le.fit_transform(newdata['Churn'])
#  
# X = newdata.loc[:, newdata.columns != target]
# Y = newdata.loc[:, newdata.columns == target]
#  
# X_train, X_test, y_train, y_test = train_test_split( X, Y, test_size=0.33, random_state=8)
#  
# from sklearn.preprocessing import StandardScaler
# sl=StandardScaler()
# X_trained= sl.fit_transform(X_train)
# X_tested= sl.fit_transform(X_test)
#  
# class_name=['yes','no']
# st.title("Machine Learning Assignment")
# html_temp = """
#     <div style="background-color:#610B21 ;padding:10px">
#     <h2 style="color:white;text-align:center;">Custormer Churn Prediction ML App </h2>
#     </div>
#     """
# st.markdown(html_temp, unsafe_allow_html=True)
#  
# st.markdown("""
# Machine Learning models which predict potential of customer to churn
# """)
# st.sidebar.title('Customer churn Prediction')
#  
# st.sidebar.markdown("""
# Machine Learning models which predict potential customer to churn
# """)
#  
# if st.sidebar.checkbox("show raw data",False):
#     st.subheader("Customer Churn for classification")
#     st.write(data)
# if st.sidebar.checkbox("Show Selected Feature"):
#     st.write(newdata)
# if st.sidebar.checkbox("Show a Statistical Analysis"):
#     st.write(newdata.describe())
# if st.sidebar.checkbox("Show a corration"):
#   st.set_option('deprecation.showPyplotGlobalUse', False)
#   st.write(sns.heatmap(newdata.corr(),annot=True))
#   st.pyplot()
#  
#  
# st.sidebar.subheader('Visualization')
# if st.sidebar.checkbox("Chart plot",False):
# 	st.area_chart(newdata)
#   
#  
# if st.sidebar.checkbox("Pie plot",False):
#   all_columns_names = newdata.columns.tolist()
#   st.write(newdata.iloc[:,-1].value_counts().plot.pie(autopct="%1.1f%%"))
#   st.set_option('deprecation.showPyplotGlobalUse', False)
#   st.pyplot()
# 
# if st.sidebar.checkbox("Histogram plot",False):
#   newdata['MonthlyCharges'].hist()
#   st.set_option('deprecation.showPyplotGlobalUse', False)
#   st.pyplot()
# 
# if st.sidebar.checkbox("Plot of Value Counts"):
#   st.text("Value Counts By Target")
#   all_columns_names = newdata.columns.tolist()
#   primary_col = st.selectbox("Primary Columm to GroupBy",all_columns_names)
#   selected_columns_names = st.multiselect("Select Columns",all_columns_names)
#   if st.button("Plot"):
#     st.text("Generate Plot")
#     if selected_columns_names:
#       vc_plot = newdata.groupby(primary_col)[selected_columns_names].count()
#     else:
#       vc_plot = newdata.iloc[:,-1].value_counts()
#     st.write(vc_plot.plot(kind="bar"))
#     st.set_option('deprecation.showPyplotGlobalUse', False)
#     st.pyplot()  
#  
#  
# st.sidebar.subheader('Choose Classifer')
# classifier_name = st.sidebar.selectbox(
#     'Choose classifier',
#     ('KNN', 'SVM', 'Random Forest','Logistic Regression','XGBOOST')
# )
# if classifier_name == 'SVM':
#     st.sidebar.subheader('Model Hyperparmeter')
#     c= st.sidebar.number_input("c(Reguralization)",0.01,10.0,step=0.01,key='c')
#     kernel= st.sidebar.radio("kernel",("linear","rbf"),key='kernel')
#     gamma= st.sidebar.radio("gamma(kernel coefficiency",("scale","auto"),key='gamma')
#  
#     metrics= st.sidebar.multiselect("What is the metrics to plot?",('confusion matrix','roc_curve','precision_recall_curve'))
#  
#     if st.sidebar.button("classify",key='classify'):
#         st.subheader("SVM result")
#         svcclassifier= SVC(C=c,kernel=kernel,gamma=gamma)
#         svcclassifier.fit(X_trained,y_train)
#         y_pred= svcclassifier.predict(X_tested)
#         acc= accuracy_score(y_test,y_pred)
#         st.write("Accuracy:",acc.round(2))
#         st.write("precision_score:",precision_score(y_test,y_pred,labels=class_name).round(2))
#         st.write("recall_score:",recall_score(y_test,y_pred,labels=class_name).round(2))
#         if 'confusion matrix' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('confusion matrix')
#             plot_confusion_matrix(svcclassifier,X_tested,y_test,display_labels=class_name)
#             st.pyplot()
#         if 'roc_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('plot_roc_curve')
#             plot_roc_curve(svcclassifier,X_tested,y_test)
#             st.pyplot()
#         if 'precision_recall_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('precision_recall_curve')
#             plot_roc_curve(svcclassifier,X_tested,y_test)
#             st.pyplot()
#         
#  
#  
# if classifier_name == 'Logistic Regression':
#     st.sidebar.subheader('Model Hyperparmeter')
#     c= st.sidebar.number_input("c(Reguralization)",0.01,10.0,step=0.01,key='Logistic')
#     max_iter= st.sidebar.slider("maximum number of iteration",100,500,key='max_item')
#    
#  
#     metrics= st.sidebar.multiselect("What is the metrics to plot?",('confusion matrix','roc_curve','precision_recall_curve'))
#  
#     if st.sidebar.button("classify",key='classify'):
#         st.subheader("Logistic Regression result")
#         Regression= LogisticRegression(C=c,max_iter=max_iter)
#         Regression.fit(X_trained,y_train)
#         y_prediction= Regression.predict(X_tested)
#         acc= accuracy_score(y_test,y_prediction)
#         st.write("Accuracy:",acc.round(2))
#         st.write("precision_score:",precision_score(y_test,y_prediction,labels=class_name).round(2))
#         st.write("recall_score:",recall_score(y_test,y_prediction,labels=class_name).round(2))
#         if 'confusion matrix' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('confusion matrix')
#             plot_confusion_matrix(Regression,X_tested,y_test,display_labels=class_name)
#             st.pyplot()
#         if 'roc_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('plot_roc_curve')
#             plot_roc_curve(Regression,X_tested,y_test)
#             st.pyplot()
#         if 'precision_recall_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('precision_recall_curve')
#             plot_roc_curve(Regression,X_tested,y_test)
#             st.pyplot()
#         
#             
#  
# if classifier_name == 'Random Forest':
#     st.sidebar.subheader('Model Hyperparmeter')
#     n_estimators= st.sidebar.number_input("Number of trees in the forest",100,5000,step=10,key='estimators')
#     max_depth= st.sidebar.number_input("maximum depth of tree",1,20,step=1,key='max_depth')
#     bootstrap= st.sidebar.radio("Boostrap sample when building trees",("True","False"),key='boostrap')
#  
#  
#     metrics= st.sidebar.multiselect("What is the metrics to plot?",('confusion matrix','roc_curve','precision_recall_curve'))
#  
#     if st.sidebar.button("classify",key='classify'):
#         st.subheader("Random Forest result")
#         model= RandomForestClassifier(n_estimators=n_estimators,max_depth=max_depth,bootstrap=bootstrap)
#         model.fit(X_trained,y_train)
#         y_prediction= model.predict(X_tested)
#         acc= accuracy_score(y_test,y_prediction)
#         st.write("Accuracy:",acc.round(2))
#         st.write("precision_score:",precision_score(y_test,y_prediction,labels=class_name).round(2))
#         st.write("recall_score:",recall_score(y_test,y_prediction,labels=class_name).round(2))
#         if 'confusion matrix' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('confusion matrix')
#             plot_confusion_matrix(model,X_tested,y_test,display_labels=class_name)
#             st.pyplot()
#         if 'roc_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('plot_roc_curve')
#             plot_roc_curve(model,X_tested,y_test)
#             st.pyplot()
#         if 'precision_recall_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('precision_recall_curve')
#             plot_roc_curve(model,X_tested,y_test)
#             st.pyplot() 
#  
#  
# if classifier_name == 'KNN':
#     st.sidebar.subheader('Model Hyperparmeter')
#     n_neighbors= st.sidebar.number_input("Number of n_neighbors",5,30,step=1,key='neighbors')
#     leaf_size= st.sidebar.slider("leaf size",30,200,key='leaf')
#     weights= st.sidebar.radio("weight function used in prediction",("uniform","distance"),key='weight')
#  
#  
#     metrics= st.sidebar.multiselect("What is the metrics to plot?",('confusion matrix','roc_curve','precision_recall_curve'))
#  
#     if st.sidebar.button("classify",key='classify'):
#         st.subheader("KNN result")
#         model= KNeighborsClassifier(n_neighbors=n_neighbors,leaf_size=leaf_size,weights=weights)
#         model.fit(X_trained,y_train)
#         y_prediction= model.predict(X_tested)
#         acc= accuracy_score(y_test,y_prediction)
#         st.write("Accuracy:",acc.round(2))
#         st.write("precision_score:",precision_score(y_test,y_prediction,labels=class_name).round(2))
#         st.write("recall_score:",recall_score(y_test,y_prediction,labels=class_name).round(2))
#         if 'confusion matrix' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('confusion matrix')
#             plot_confusion_matrix(model,X_tested,y_test,display_labels=class_name)
#             st.pyplot()
#         if 'roc_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('plot_roc_curve')
#             plot_roc_curve(model,X_tested,y_test)
#             st.pyplot()
#         if 'precision_recall_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('precision_recall_curve')
#             plot_roc_curve(model,X_tested,y_test)
#             st.pyplot() 
#  
#  
# if classifier_name == 'XGBOOST':
#     st.sidebar.subheader('Model Hyperparmeter')
#     n_estimators= st.sidebar.number_input("Number of trees in the forest",100,5000,step=10,key='XGBestimators')
#     seed= st.sidebar.number_input("number of the seed",1,150,step=1,key='seed')
#     
#     
#     
#  
#  
#     metrics= st.sidebar.multiselect("What is the metrics to plot?",('confusion matrix','roc_curve','precision_recall_curve'))
#  
#     if st.sidebar.button("classify",key='classify'):
#         st.subheader("XGBOOST result")
#         model= xgb.XGBClassifier(n_estimators=n_estimators,seed=seed)
#         model.fit(X_trained,y_train)
#         y_prediction= model.predict(X_tested)
#         acc= accuracy_score(y_test,y_prediction)
#         st.write("Accuracy:",acc.round(2))
#         st.write("precision_score:",precision_score(y_test,y_prediction,labels=class_name).round(2))
#         st.write("recall_score:",recall_score(y_test,y_prediction,labels=class_name).round(2))
#         st.write("ROC_AUC_score:",roc_auc_score(y_test,y_prediction).round(2))
#  
#        
#  
#         if 'confusion matrix' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('confusion matrix')
#             plot_confusion_matrix(model,X_tested,y_test,display_labels=class_name)
#             st.pyplot()
#         if 'roc_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('plot_roc_curve')
#             plot_roc_curve(model,X_tested,y_test)
#             st.pyplot()
#         if 'precision_recall_curve' in metrics:
#             st.set_option('deprecation.showPyplotGlobalUse', False)
#             st.subheader('precision_recall_curve')
#             plot_roc_curve(model,X_tested,y_test)
#             st.pyplot() 
# st.sidebar.subheader('Model Prediction') 
# if st.sidebar.checkbox("Do you want to predict?",key='prediction'):
#     list=[]
#     st.subheader('Please fill out this form')
#     cols=['tenure','Contract','OnlineSecurity','TechSupport','OnlineBackup','DeviceProtection','MonthlyCharges','Churn']
#     
#     tenure = st.slider("what is your tenure values",1,200,key='tenure')
#     list.append(tenure)
#  
#     Contract = st.selectbox(
#     'what is your Contract?',
#     ('Month-to-month', 'One year','Two year'))
#     if Contract == 'Month-to-month':
#       list.append(0)
#     elif Contract == 'One year':
#       list.append(1)  
#     else:
#       list.append(2)
#  
#     security = st.radio("Do you have online security?",('No', 'Yes', 'No internet service'))
#     if security == 'Yes':
#       #st.success("You are Active")
#       list.append(2)
#     elif security == 'No':
#       #st.success("You are Active")
#       list.append(0)  
#     else:
#       list.append(1)
#       #st.warning("Inactive, Activate") 
#  
#     techsupport = st.radio("Do you have Tech support?",('No', 'Yes', 'No internet service'))
#     if techsupport == 'Yes':
#       #st.success("You are Active")
#       list.append(2)
#     elif techsupport == 'No':
#       #st.success("You are Active")
#       list.append(0)  
#     else:
#       list.append(1)  
#  
#     OnlineBackup = st.selectbox("Do you have online backup",
#     ('Yes', 'No', 'No internet service'))
#     if OnlineBackup == 'Yes':
#       #st.success("You are Active")
#       list.append(2)
#     elif OnlineBackup == 'No':
#       #st.success("You are Active")
#       list.append(0)  
#     else:
#       list.append(1)
#       #st.warning("Inactive, Activate")
#  
#     DeviceProtection = st.radio("Do you have Device Protection",("Yes","No","No internet service"))
#     if DeviceProtection == 'Yes':
#       #st.success("You are Active")
#       list.append(2)
#     elif DeviceProtection == 'No':
#       #st.success("You are Active")
#       list.append(0)  
#     else:
#       list.append(1)
#       #st.warning("Inactive, Activate")  
#  
#     
#     monthlycharge = st.text_input("what is your monthly charge","Type Here")
#     list.append(monthlycharge)
#  
#  
#     if st.button("Prediction",key='predict'):
#          my_array= np.array([list])
#          #model= xgb.XGBClassifier(n_estimators=400,seed=14,learning_rate=0.3)
#          #model.fit(X_trained,y_train)
#          xgbmodel=pickle.load(open('models.pkl','rb'))
#          y_user_prediction= xgbmodel.predict(my_array)
#          if y_user_prediction==0:
#           st.subheader("a new customer can not result in a churn")
#           st.balloons()
#          elif y_user_prediction==1:
#           st.subheader("a new customer can  result in a churn")
#           st.balloons()

!ls

!streamlit run app.py &>/dev/null&

from pyngrok import ngrok

# Setup a tunnel to the streamlit port 8501
public_url = ngrok.connect(port='8501')
public_url

